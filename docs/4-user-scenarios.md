# Python Judge 사용자 시나리오
> 업데이트(군번 제거): 모든 시나리오에서 군번 입력 단계를 제거하고 ID/이름/비밀번호만 사용합니다.

**버전**: 1.0
**최종 수정일**: 2025-11-26
**작성자**: Business Analyst & Technical Writer
**상태**: 확정

## 변경 이력

| 버전 | 날짜       | 변경 내용 | 작성자                          |
| ---- | ---------- | --------- | ------------------------------- |
| 1.0  | 2025-11-26 | 초안 작성 | Business Analyst, Technical Writer |

---

## 1. 개요

본 문서는 Python Judge 플랫폼의 실제 사용 시나리오를 구체적으로 기술합니다. 학생과 관리자의 관점에서 일상적인 사용 패턴부터 특수 상황까지 다양한 시나리오를 제공하여, 실제 사용 환경에서의 플랫폼 동작을 이해할 수 있도록 합니다.

---

## 2. 학생 사용 시나리오

### 시나리오 1: 첫 문제 도전 (신규 학생)

**배경**: 김병장은 Python 교육 과정에 참여한 첫날로, 처음으로 Python Judge를 사용합니다.

**목표**: 회원가입부터 첫 문제 풀이까지 완료하기

**사용 흐름**:

1. **회원가입**
   - 교육 담당자로부터 받은 사이트 주소로 접속
   - "회원가입" 버튼 클릭
   - 군번: `12345678`, ID: `kim_soldier`, 이름: `김병장`, 비밀번호 입력
   - 가입 완료 후 자동 로그인

2. **문제 탐색**
   - 메인 화면에서 카테고리 목록 확인
   - "1. 변수, 연산자, 자료형" 카테고리 선택
   - 난이도 1-2 문제들이 나열됨
   - "Hello World 출력하기" 문제 선택

3. **문제 이해**
   - 좌측에서 문제 설명 읽기
     - 문제: "Hello, World!"를 출력하는 프로그램 작성
     - 입력: 없음
     - 출력: `Hello, World!` (정확히 이 형식으로)
   - 예제 입출력 확인
   - 제약 조건: 시간 제한 2초, 메모리 256MB

4. **코드 작성 및 제출**
   - 우측 코드 에디터에 작성:
     ```python
     print("Hello, World!")
     ```
   - Python 버전 3.10 선택
   - "제출" 버튼 클릭

5. **결과 확인**
   - 채점 중... 스피너 표시 (약 3초 소요)
   - **결과: 정답 (AC)** ✅
   - 통과한 테스트 케이스: 1/1
   - 실행 시간: 0.02초
   - 메모리 사용량: 8MB
   - 성취감과 함께 다음 문제로 이동

**예상 소요 시간**: 10분

**성공 지표**:
- 회원가입 완료율: 100%
- 첫 문제 정답률: 85%
- 첫 로그인 후 문제 풀이까지 평균 시간: 15분

---

### 시나리오 2: 디버깅 과정 (중급 학생)

**배경**: 이상병은 "FizzBuzz" 문제를 풀고 있지만, 계속 오답(WA)이 나옵니다.

**목표**: 오답 원인을 파악하고 정답 제출하기

**사용 흐름**:

1. **문제 선택**
   - 카테고리 "2. 조건문" 선택
   - "FizzBuzz" 문제 클릭
   - 문제 내용:
     - 1부터 N까지의 수를 출력하되,
     - 3의 배수면 "Fizz", 5의 배수면 "Buzz", 15의 배수면 "FizzBuzz"
     - 입력: 정수 N (1 ≤ N ≤ 100)

2. **첫 번째 시도**
   ```python
   n = int(input())
   for i in range(1, n+1):
       if i % 15 == 0:
           print("FizzBuzz")
       elif i % 3 == 0:
           print("Fizz")
       elif i % 5 == 0:
           print("Buzz")
       else:
           print(i)
   ```
   - 제출
   - **결과: 오답 (WA)** ❌
   - 통과한 테스트 케이스: 2/5
   - 어떤 테스트 케이스가 틀렸는지는 비공개

3. **디버깅 시도**
   - 예제 입출력 다시 확인
   - 예제 입력: `15`
   - 예상 출력과 직접 실행 결과 비교
   - 로컬에서 테스트:
     ```
     1
     2
     Fizz
     4
     Buzz
     ...
     FizzBuzz
     ```
   - 예제는 통과하는데 비공개 케이스에서 실패

4. **두 번째 시도**
   - 출력 형식 재확인 (줄바꿈, 공백 등)
   - 코드 수정 (실제로는 동일)
   - 다시 제출
   - **결과: 오답 (WA)** ❌
   - 여전히 2/5 통과

5. **문제 재분석**
   - 문제 설명 다시 읽기
   - "3의 배수이면서 5의 배수가 아닌 경우만 Fizz" 확인
   - 아! 15의 배수를 먼저 체크해야 함 (이미 했음)
   - 혹시 N=0 같은 엣지 케이스?
   - 문제 제약 조건 재확인: 1 ≤ N ≤ 100

6. **세 번째 시도 - 출력 포맷 수정**
   - 혹시 마지막 줄바꿈이 문제?
   ```python
   n = int(input())
   result = []
   for i in range(1, n+1):
       if i % 15 == 0:
           result.append("FizzBuzz")
       elif i % 3 == 0:
           result.append("Fizz")
       elif i % 5 == 0:
           result.append("Buzz")
       else:
           result.append(str(i))
   print('\n'.join(result))
   ```
   - 제출
   - **결과: 정답 (AC)** ✅
   - 통과한 테스트 케이스: 5/5
   - 실행 시간: 0.05초
   - **참고**: Python Judge는 trailing whitespace와 줄바꿈 차이는 무시하므로, 실제로는 첫 번째 코드도 정답이었을 가능성이 높음. 하지만 로직 차이로 인해 다른 결과가 나왔을 수 있음.

7. **제출 이력 확인**
   - "제출 이력" 메뉴 클릭
   - 3번의 시도 기록 확인
   - 시도 1, 2: WA (2/5), 시도 3: AC (5/5)
   - 교훈: 출력 형식 주의, 하지만 공백이나 줄바꿈 차이는 자동으로 정규화됨

**예상 소요 시간**: 25분 (3회 시도)

**학습 효과**:
- 디버깅 능력 향상
- 출력 형식의 중요성 인식
- 반복 학습을 통한 문제 해결 능력 강화

---

### 시나리오 3: 교육 세션 참여 (평가 상황)

**배경**: 박일병은 "반복문 평가" 세션에 참여하여 4개 문제를 제한 시간 내에 풀어야 합니다.

**목표**: 세션 내 최대한 많은 문제를 정답 처리하고 높은 순위 달성

**사용 흐름**:

1. **세션 시작 전**
   - 로그인 후 "현재 진행 중인 세션" 알림 확인
   - "반복문 평가 세션" 클릭
   - 세션 정보:
     - 시작: 14:00, 종료: 16:00 (2시간)
     - 할당된 문제: 4개
     - 참여 학생: 24명
     - 재제출 허용

2. **문제 1: 구구단 출력 (난이도 1)**
   - 14:05 - 문제 읽기 및 코드 작성 시작
   - 14:10 - 제출
   - **결과: 정답 (AC)** ✅
   - 스코어보드 확인: 현재 3위
   - 소요 시간: 5분

3. **문제 2: 별 찍기 (난이도 2)**
   - 14:12 - 문제 시작
   - 14:20 - 첫 제출
   - **결과: 오답 (WA)** ❌ (4/7 통과)
   - 14:25 - 수정 후 재제출
   - **결과: 정답 (AC)** ✅
   - 스코어보드: 5위로 하락 (재제출 패널티)
   - 소요 시간: 13분

4. **실시간 스코어보드 확인**
   - 자동 새로고침 (5초마다)
   - 현재 순위: 5위
   - 1위: 김병장 (3문제 정답)
   - 2위: 최상병 (3문제 정답, 시간 더 소요)
   - 자신: 2문제 정답
   - 순위 변동 애니메이션 확인

5. **문제 3: 소수 판별 (난이도 3)**
   - 14:30 - 문제 시작
   - 복잡한 로직, 시간 제한 걱정
   - 14:50 - 제출
   - **결과: 시간 초과 (TLE)** ⏱️
   - 알고리즘 최적화 필요
   - 14:58 - 최적화 후 재제출
   - **결과: 정답 (AC)** ✅
   - 스코어보드: 4위로 상승
   - 소요 시간: 28분

6. **문제 4: 최대공약수 (난이도 2)**
   - 15:05 - 마지막 문제 시작
   - 15:15 - 제출
   - **결과: 정답 (AC)** ✅
   - 스코어보드: 2위로 도약!
   - 소요 시간: 10분

7. **세션 종료**
   - 16:00 - 세션 자동 종료
   - 최종 순위: 2위 / 24명
   - 해결 문제: 4/4
   - 총 제출 횟수: 6회 (정답 4, 오답 1, TLE 1)
   - 세션 완료 축하 메시지
   - 성취도 분석 리포트 확인

**예상 소요 시간**: 2시간 (세션 전체)

**성공 지표**:
- 세션 참여율: 95%
- 평균 문제 해결률: 75%
- 학생 만족도: 4.5/5

---

### 시나리오 4: 제출 이력 분석 (복습 단계)

**배경**: 최상병은 한 주간의 학습을 마치고 자신의 학습 패턴을 분석합니다.

**목표**: 제출 이력을 통해 약점 파악 및 복습 계획 수립

**사용 흐름**:

1. **제출 이력 조회**
   - "제출 이력" 메뉴 클릭
   - 최근 1주일간 총 47개 제출 기록 확인
   - 필터: "모든 결과" → "오답(WA)" 선택
   - 오답 제출 15건 확인

2. **통계 분석**
   - 카테고리별 정답률 확인:
     - 변수, 연산자: 100% (10/10)
     - 조건문: 85% (17/20)
     - 문자열: 70% (7/10) ⚠️
     - 반복문: 90% (9/10)
   - **약점 발견**: 문자열 처리가 취약

3. **오답 문제 재도전**
   - 문자열 카테고리의 오답 문제 3개 선택
   - "회문 판별" 문제 다시 풀기:
     - 이전 제출 코드 확인
     - 실수 발견: 대소문자 구분 안 함
     - 수정 후 제출
     - **결과: 정답 (AC)** ✅

4. **학습 계획 수립**
   - 문자열 관련 추가 문제 5개 북마크
   - 다음 주 학습 목표: 문자열 정답률 90% 이상 달성
   - 교육자에게 문자열 관련 질문 준비

**예상 소요 시간**: 30분

**학습 효과**:
- 자기주도 학습 능력 향상
- 약점 파악 및 집중 학습 전략 수립
- 메타인지 능력 발달

---

## 3. 관리자 사용 시나리오

### 시나리오 5: 문제 출제 (신규 문제 등록)

**배경**: 서중사는 "딕셔너리" 카테고리에 새로운 문제를 추가하려고 합니다.

**목표**: 문제와 테스트 케이스를 등록하여 학생들이 풀 수 있도록 공개

**사용 흐름**:

1. **관리자 로그인**
   - 관리자 ID와 비밀번호로 로그인
   - 관리자 대시보드 화면 표시

2. **문제 등록 시작**
   - "문제 관리" 메뉴 클릭
   - "새 문제 등록" 버튼 클릭
   - 문제 등록 폼 표시

3. **문제 정보 입력**
   - 제목: "단어 빈도수 세기"
   - 설명:
     ```
     주어진 문장에서 각 단어의 출현 빈도를 세어 딕셔너리로 출력하세요.
     단어는 공백으로 구분되며, 대소문자를 구분하지 않습니다.

     입력: 한 줄의 문장 (최대 1000자)
     출력: 단어와 빈도수를 {단어: 빈도} 형식으로 출력
     ```
   - 카테고리: "6. 딕셔너리, 집합"
   - 난이도: 2 (1-5 중)
   - 시간 제한: 2초
   - 메모리 제한: 256MB
   - 예제 입출력:
     - 입력: `Hello world hello`
     - 출력: `{'hello': 2, 'world': 1}`

4. **테스트 케이스 등록**
   - "테스트 케이스 추가" 버튼 클릭

   - **공개 테스트 케이스 1** (학생에게 보임)
     - 입력: `Hello world hello`
     - 출력: `{'hello': 2, 'world': 1}`
     - 공개 여부: ✅

   - **비공개 테스트 케이스 2**
     - 입력: `Python Python python PYTHON`
     - 출력: `{'python': 4}`
     - 공개 여부: ❌

   - **비공개 테스트 케이스 3**
     - 입력: `a`
     - 출력: `{'a': 1}`
     - 공개 여부: ❌

   - **비공개 테스트 케이스 4**
     - 입력: `The quick brown fox jumps over the lazy dog`
     - 출력: `{'the': 2, 'quick': 1, 'brown': 1, ...}`
     - 공개 여부: ❌

   - ... 총 12개 테스트 케이스 등록

5. **문제 검증**
   - "미리보기" 버튼으로 학생 화면 확인
   - 테스트 케이스 정상 동작 확인
   - 정답 코드 직접 작성 및 테스트:
     ```python
     from collections import Counter
     sentence = input().lower().split()
     word_count = dict(Counter(sentence))
     print(word_count)
     ```
   - 자동 채점 테스트: **AC (12/12)** ✅

6. **문제 공개**
   - 공개 상태: "비공개" → "공개" 변경
   - 저장 버튼 클릭
   - 문제 등록 완료 알림
   - 학생들이 즉시 문제를 볼 수 있음

**예상 소요 시간**: 20분

**성공 지표**:
- 문제 등록 소요 시간: 평균 15분
- 테스트 케이스 품질: 95% 정확도
- 학생 첫 시도 정답률: 60-70% (적절한 난이도)

---

### 시나리오 6: 교육 세션 운영 (모의고사)

**배경**: 김대위는 Python 교육 과정의 중간 평가를 위한 모의고사를 진행합니다.

**목표**: 교육 세션을 생성하고, 실시간으로 학생들의 진행 상황을 모니터링

**사용 흐름**:

1. **세션 생성**
   - 관리자 대시보드 → "세션 관리"
   - "새 세션 만들기" 클릭
   - 세션 정보 입력:
     - 이름: "Python 중간 평가 - 1차"
     - 타입: "모의고사"
     - 시작 시각: 2025-11-26 14:00
     - 종료 시각: 2025-11-26 16:00 (2시간)
     - 재제출 허용: ✅

2. **학생 및 문제 할당**
   - 대상 학생 선택:
     - "전체 학생 선택" (24명)
     - 또는 개별 선택/제외 가능
   - 문제 선택:
     - 카테고리별 문제 필터링
     - 선택한 문제 (총 5개):
       1. 조건문 - FizzBuzz (난이도 2)
       2. 반복문 - 별 찍기 (난이도 2)
       3. 딕셔너리 - 단어 빈도수 (난이도 2)
       4. 함수 - 재귀 함수 (난이도 3)
       5. 리스트 - 정렬 구현 (난이도 4)
   - "세션 생성" 버튼 클릭

3. **세션 시작**
   - 14:00 - 세션 자동 시작
   - 학생들에게 세션 시작 알림 전송
   - 관리자 화면에서 실시간 모니터링 시작

4. **실시간 모니터링**
   - **스코어보드 확인** (5초마다 자동 갱신)
     - 14:05 - 3명이 문제 1 정답 제출
     - 14:15 - 10명이 문제 1 정답, 5명이 문제 2 진행 중
     - 14:30 - 15명이 2문제 이상 해결

   - **제출 현황 모니터링**
     - 총 제출 횟수: 47건
     - 정답(AC): 32건
     - 오답(WA): 12건
     - 시간초과(TLE): 3건

   - **학생별 진행 상황**
     | 학생   | 해결 문제 | 최근 제출      | 상태       |
     | ------ | --------- | -------------- | ---------- |
     | 김병장 | 4/5       | 문제 5 (진행중) | 활발       |
     | 이상병 | 3/5       | 문제 4 (WA)    | 어려움     |
     | 박일병 | 2/5       | 문제 3 (AC)    | 정상 진행  |
     | 최이병 | 1/5       | 문제 2 (진행중) | 느린 진행  |

5. **실시간 개입**
   - 15:30 - 최이병이 2문제만 풀고 멈춤
   - 별도 창으로 최이병의 제출 이력 확인
   - 문제 3에서 계속 오답
   - 현장에서 최이병에게 힌트 제공 (오프라인)

6. **세션 종료**
   - 16:00 - 세션 자동 종료
   - 학생들의 추가 제출 차단
   - 최종 스코어보드 확정:
     | 순위 | 학생   | 해결 문제 | 총점 |
     | ---- | ------ | --------- | ---- |
     | 1    | 김병장 | 5/5       | 500  |
     | 2    | 이상병 | 4/5       | 400  |
     | 3    | 박일병 | 4/5       | 400  |
     | ... |

7. **성취도 분석**
   - "성취도 리포트" 생성 버튼 클릭
   - 분석 결과:
     - 전체 평균 정답률: 68%
     - 문제별 정답률:
       - 문제 1 (FizzBuzz): 95%
       - 문제 2 (별 찍기): 80%
       - 문제 3 (단어 빈도수): 70%
       - 문제 4 (재귀 함수): 45% ⚠️
       - 문제 5 (정렬 구현): 30% ⚠️
     - **약점 발견**: 재귀와 알고리즘 구현이 취약
     - 다음 교육 계획: 재귀 함수 집중 교육

**예상 소요 시간**: 2.5시간 (준비 30분 + 세션 2시간)

**성공 지표**:
- 세션 생성 소요 시간: 평균 10분
- 모니터링 업데이트 주기: 5초
- 평가 데이터 수집 완료율: 100%
- 관리자 만족도: 4.5/5

---

### 시나리오 7: 세션 초기화 (재평가 준비)

**배경**: 박중사는 지난 주 진행한 "반복문 평가" 세션을 다시 활용하여 이번 주 신규 입과자들을 평가하려고 합니다.

**목표**: 기존 세션의 데이터를 초기화하고 새로운 평가 준비

**사용 흐름**:

1. **세션 선택**
   - "세션 관리" 메뉴 → "과거 세션" 탭
   - "반복문 평가 - 1차" 세션 선택
   - 세션 정보 확인:
     - 참여 학생: 24명
     - 문제: 4개
     - 제출 이력: 87건

2. **세션 복제**
   - "세션 복제" 버튼 클릭
   - 새 세션 이름: "반복문 평가 - 2차"
   - 시작/종료 시각 변경:
     - 시작: 2025-12-03 14:00
     - 종료: 2025-12-03 16:00

3. **학생 교체**
   - 기존 학생 목록 제거
   - 신규 입과자 24명 추가
   - 문제는 동일하게 유지

4. **세션 초기화 확인**
   - ⚠️ 경고 메시지 표시:
     ```
     세션을 복제하면 기존 제출 이력과 스코어보드가 초기화됩니다.
     복구할 수 없으니 신중히 결정하세요.
     초기화하시겠습니까?
     ```
   - "초기화" 버튼 클릭
   - 관리자 비밀번호 재확인
   - 초기화 완료

5. **감사 로그 기록**
   - 자동으로 감사 로그에 기록:
     ```
     [2025-12-02 10:30:15]
     관리자: 박중사 (ID: park_admin)
     행위: 세션 복제 및 초기화
     대상: "반복문 평가 - 1차" → "반복문 평가 - 2차"
     IP: 192.168.1.100
     결과: 성공
     ```

6. **새 세션 확인**
   - "반복문 평가 - 2차" 세션 상세 보기
   - 참여 학생: 신규 24명
   - 제출 이력: 0건
   - 스코어보드: 비어 있음
   - 세션 상태: 예정 (12월 3일 자동 시작)

**예상 소요 시간**: 10분

**주의 사항**:
- 세션 초기화는 복구 불가능
- 반드시 기존 데이터를 백업한 후 진행 (자동 백업)
- 감사 로그에 모든 활동 기록

---

## 4. 특수 상황 시나리오

### 시나리오 8: 에러 상황 대응

**배경**: 장병장이 코드를 제출했지만 예상치 못한 에러가 발생합니다.

**사용 흐름**:

1. **런타임 에러 (Runtime Error)**
   - 코드 제출:
     ```python
     n = int(input())
     print(10 / n)  # n=0일 때 ZeroDivisionError
     ```
   - **결과: 런타임 에러 (RE)** 💥
   - 에러 메시지: `ZeroDivisionError: division by zero`
   - 학생은 에러 메시지를 보고 코드 수정
   - 예외 처리 추가 후 재제출

2. **시간 초과 (Time Limit Exceeded)**
   - 비효율적인 알고리즘 사용:
     ```python
     # O(n^3) 알고리즘
     for i in range(n):
         for j in range(n):
             for k in range(n):
                 # ...
     ```
   - **결과: 시간 초과 (TLE)** ⏱️
   - 실행 시간: 10.02초 (제한: 10초)
   - 학생은 알고리즘 최적화 필요

3. **메모리 초과 (Memory Limit Exceeded)**
   - 과도한 메모리 할당:
     ```python
     huge_list = [0] * (10**9)  # 약 4GB
     ```
   - **결과: 메모리 초과 (MLE)** 💾
   - 메모리 사용량: 280MB (제한: 256MB)
   - 학생은 메모리 사용량 최적화

4. **금지 모듈 사용 (Syntax Error)**
   - 금지된 모듈 import:
     ```python
     import os
     os.system('ls')  # 금지!
     ```
   - **결과: 문법 오류 (SE)** 🚫
   - 에러 메시지: `Forbidden module detected: os`
   - AST 정적 분석으로 사전 차단
   - 학생은 허용된 모듈만 사용하도록 수정

**학습 효과**:
- 에러 메시지 해석 능력 향상
- 예외 처리의 중요성 인식
- 알고리즘 효율성 고려
- 보안 정책 이해

---

### 시나리오 9: 답안 정규화로 인한 정답 처리

**배경**: 한일병은 Windows 환경에서 코드를 작성하고, 출력에 여분의 공백이 들어갔지만 정답 처리되는 경험을 합니다.

**목표**: 답안 정규화 메커니즘 이해하기

**사용 흐름**:

1. **문제: 두 수의 합**
   - 두 정수 A, B를 입력받아 합을 출력
   - 예제:
     - 입력: `3 5`
     - 출력: `8`

2. **첫 번째 제출 - Windows 환경**
   ```python
   a, b = map(int, input().split())
   print(a + b)    # 실수로 공백 여러 개 입력
   ```
   - Windows에서 작성하여 CRLF(`\r\n`) 줄바꿈 사용
   - 실제 출력: `8    \r\n` (숫자 뒤 공백 4개 + CRLF)
   - 예상 출력: `8\n` (LF 줄바꿈)
   - **결과: 정답 (AC)** ✅
   - 학생 놀람: "출력이 달라 보이는데 왜 정답?"

3. **두 번째 문제: 여러 줄 출력**
   - 1부터 N까지 출력
   ```python
   n = int(input())
   for i in range(1, n+1):
       print(i)


   # 실수로 빈 줄 여러 개 추가
   ```
   - 실제 출력: `1\n2\n3\n\n\n` (마지막에 빈 줄 2개)
   - 예상 출력: `1\n2\n3\n`
   - **결과: 정답 (AC)** ✅
   - 이유: 출력 전체의 trailing empty lines 제거

4. **세 번째 문제: 부동소수점**
   - 원의 넓이 계산 (반지름 r 입력)
   ```python
   import math
   r = float(input())
   area = math.pi * r * r
   print(area)
   ```
   - 학생 출력: `3.141592653589793` (Python의 기본 float 정밀도)
   - 예상 출력: `3.141592654` (소수점 9자리)
   - **결과: 정답 (AC)** ✅
   - 이유: 상대 오차 1e-9 이내

5. **네 번째 문제: 의미 있는 공백**
   - 구구단을 표 형태로 출력
   ```python
   # 잘못된 예: 곱하기 기호 양옆 공백 누락
   for i in range(2, 10):
       for j in range(1, 10):
           print(f"{i}*{j}={i*j}")  # 공백 없음
   ```
   - 학생 출력: `2*1=2`
   - 예상 출력: `2 * 1 = 2` (연산자 양옆 공백)
   - **결과: 오답 (WA)** ❌
   - 이유: 의미 있는 공백 차이는 정규화하지 않음

6. **정규화 규칙 이해**
   - 한일병이 학습한 내용:
     - ✅ 줄 끝 공백(trailing whitespace)은 무시됨
     - ✅ 줄바꿈 문자(LF/CRLF/CR) 차이는 무시됨
     - ✅ 마지막 빈 줄은 무시됨
     - ✅ 부동소수점은 미세한 오차 허용
     - ❌ 단어 사이 공백 등 의미 있는 공백은 정확해야 함
     - ❌ 대소문자는 기본적으로 구분됨

**예상 소요 시간**: 20분

**학습 효과**:
- 답안 정규화 메커니즘 이해
- 형식적 차이와 의미적 차이 구분 능력
- 출력 형식 설계 시 주의사항 학습
- 플랫폼의 학생 친화적 채점 방식 인지

**추가 정규화 예시**:

| 학생 출력 | 예상 출력 | 결과 | 이유 |
|----------|----------|------|------|
| `"Hello\r\n"` (Windows) | `"Hello\n"` (Linux) | ✅ AC | 줄바꿈 정규화 |
| `"123  \n"` (trailing 공백) | `"123\n"` | ✅ AC | trailing whitespace 제거 |
| `"  123\n"` (leading 공백) | `"123\n"` | ❌ WA | leading whitespace는 의미 있음 |
| `"3.14159\n"` | `"3.14160\n"` | ✅ AC | 상대 오차 1e-9 이내 |
| `"HELLO\n"` | `"hello\n"` | ❌ WA | 대소문자 구분 (기본) |
| `"1\n2\n\n"` (마지막 빈 줄) | `"1\n2\n"` | ✅ AC | trailing empty lines 제거 |

---

### 시나리오 10: 제출 부하 대응

**배경**: 조병장이 제출이 몰리는 시간대에 시스템이 혼잡한 상황입니다.

**사용 흐름**:

1. **채점 큐 초과 (전체 500개 제한)**
   - 시스템 전체 제출이 폭주하는 상황
   - 학생이 제출 시도
   - ⚠️ 에러 메시지 (HTTP 429):
     ```
     서버가 혼잡합니다. 잠시 후 다시 시도해주세요.
     (현재 채점 대기: 500건)
     ```
   - 1분 후 재시도

**보호 효과**:
- 서버 과부하 방지
- 재시도 시점 안내로 사용자 혼선 최소화
- 시스템 안정성 유지

---

## 5. 시나리오 요약표

| 시나리오                      | 사용자 | 소요 시간 | 핵심 기능                                    | 학습 목표                      |
| ----------------------------- | ------ | --------- | -------------------------------------------- | ------------------------------ |
| 1. 첫 문제 도전               | 학생   | 10분      | 회원가입, 문제 조회, 코드 제출, 자동 채점    | 플랫폼 사용법 익히기           |
| 2. 디버깅 과정                | 학생   | 25분      | 반복 제출, 제출 이력, 오답 분석              | 디버깅 능력 향상               |
| 3. 교육 세션 참여             | 학생   | 2시간     | 세션 참여, 실시간 스코어보드, 제한 시간 평가 | 평가 환경 적응                 |
| 4. 제출 이력 분석             | 학생   | 30분      | 제출 이력, 통계 분석, 약점 파악              | 자기주도 학습                  |
| 5. 문제 출제                  | 관리자 | 20분      | 문제 등록, 테스트 케이스 관리, 검증          | 문제 품질 관리                 |
| 6. 교육 세션 운영             | 관리자 | 2.5시간   | 세션 생성, 실시간 모니터링, 성취도 분석      | 효율적 평가 운영               |
| 7. 세션 초기화                | 관리자 | 10분      | 세션 복제, 데이터 초기화, 감사 로그          | 재사용 가능한 평가 관리        |
| 8. 에러 상황 대응             | 학생   | 변동      | RE/TLE/MLE/SE 처리, 에러 메시지 해석         | 에러 처리 능력 향상            |
| 9. 답안 정규화 이해           | 학생   | 20분      | 공백/줄바꿈 정규화, 부동소수점 오차 허용     | 답안 정규화 메커니즘 이해      |
| 10. 제출 부하 대응            | 학생   | 변동      | 채점 큐 관리, 혼잡 시 재시도 흐름            | 시스템 제약 이해               |

---

## 6. 사용자 여정 맵 (User Journey Map)

### 학생의 1주차 학습 여정

```
Day 1 (월):
  회원가입 → 첫 문제 도전 → 10문제 풀이 (정답률 70%)
  감정: 😊 설렘, 약간의 긴장

Day 2 (화):
  조건문 카테고리 집중 → 15문제 풀이 (정답률 80%)
  감정: 😃 자신감 상승

Day 3 (수):
  반복문 도전 → 오답 많이 발생 (정답률 60%)
  감정: 😟 좌절감, 디버깅 필요성 인식

Day 4 (목):
  제출 이력 분석 → 약점 파악 → 복습
  감정: 🤔 반성, 학습 계획 수립

Day 5 (금):
  모의고사 세션 참여 → 4/5 문제 해결 → 2위!
  감정: 🎉 성취감, 동기부여

주말:
  추가 연습 문제 풀이 (자율 학습)
  감정: 💪 열정, 다음 주 기대
```

### 관리자의 1주차 운영 여정

```
Day 1 (월):
  신규 문제 3개 등록 → 학생 계정 확인
  활동: 📝 문제 출제

Day 2-4 (화-목):
  학생 진도 모니터링 → 질문 대응
  활동: 👀 모니터링, 💬 지원

Day 5 (금):
  모의고사 세션 운영 → 실시간 모니터링 → 성취도 분석
  활동: 🎯 평가, 📊 분석

주말:
  다음 주 교육 계획 수립 → 신규 문제 준비
  활동: 📅 계획, 📝 준비
```

---

## 7. 시나리오 기반 개선 사항

### 사용자 피드백 기반 개선

1. **학생 요청사항**:
   - 문제별 정답률 및 평균 시도 횟수 표시 → Phase 2 반영
   - 코드 제출 후 예상 실행 시간 표시 → 기술적 검토 필요
   - 오답 시 힌트 제공 기능 → Phase 2 검토

2. **관리자 요청사항**:
   - 문제 난이도 자동 조정 (정답률 기반) → Phase 2 반영
   - 학생별 성취도 리포트 엑셀 다운로드 → MVP 반영
   - 세션 템플릿 저장 기능 → Phase 2 반영

3. **시스템 개선**:
   - 채점 속도 최적화 (목표: 평균 3초) → 지속 개선
   - 에러 메시지 다국어 지원 → Phase 3
   - 모바일 최적화 → Phase 2

---

## 8. 결론

본 사용자 시나리오 문서는 Python Judge 플랫폼의 실제 사용 환경을 구체적으로 제시하여, 개발 과정에서 사용자 중심 설계를 유지하고, 실제 사용 시 발생할 수 있는 다양한 상황을 사전에 고려할 수 있도록 합니다.

### 핵심 가치 재확인

1. **학생 관점**: 즉각적 피드백, 자기주도 학습, 성취감
2. **관리자 관점**: 효율적 평가 운영, 실시간 모니터링, 데이터 기반 의사결정
3. **시스템 관점**: 안정성, 보안성, 확장성

### 다음 단계

- [ ] 사용자 시나리오 기반 UI/UX 프로토타입 제작
- [ ] 핵심 시나리오 E2E 테스트 작성
- [ ] 사용자 피드백 수집 프로세스 수립
- [ ] 시나리오 기반 성능 테스트 계획 수립

---

**문서 종료**


